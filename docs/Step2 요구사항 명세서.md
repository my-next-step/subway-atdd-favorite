# 요구사항 설명

* 1,2단계에서 구현한 인증 로직에 대한 리팩터링을 진행하세요
* 내 정보 수정 / 삭제 기능을 처리하는 기능을 구현하세요.
* Controller 에서 @ㅐ너테이션을 활용하여 Login 정보에 접근

## 인증 로직에 대한 리펙터링  
  
* 중복이 발생되는 부분이라고 생각이 든다.(Interceptor)       
* 메서드가 중복되기에, 인터페이스로 분리 + ISP 원칙으로 각각 하나씩 분리     

**그런데 기존 코드를 건드리지말고 어떻게 적용하지? 🤔**   
1. 인터페이스 만들고, 새로운 이름의 클래스 만들어서 해당 클래스 테스트하기 
2. 인터페이스 만들고, 구현체를 Mock 으로 테스트하기 -> 실제 객체로 전환

여기서는 완전히 동일 인터페이스로 새로운걸 만든다면(세션 -> token) 1번이 괜찮지만     
현재는 이미 만들어진 2개를 인터페이스로 전환시키는 작업이니까 2번이 괜찮은 것 같다.   

## 내 정보 수정 / 삭제 기능을 처리하는 기능을 구현하세요.

* 저번 미션에 Transactional 하면서 적용됨  

## Controller 에서 @ㅐ너테이션을 활용하여 Login 정보에 접근   

* ArgumentResolver 를 만들어서 처리   
* ㅐ너테이션으로 생성 가능한데 해봐야겠다.  

# 리팩토링 과정
> 아는것에서 모르는 것으로 + 가장 작은 단위부터 큰 곳으로 

1. **UserDetailsService를 추상화 하여 auth -> member 의존을 제거하기** 
    * UserDetailsService 는 여러 인터셉터에서 공용으로 사용되고 있다.  
    * 즉, 가장 먼저 리팩터링할 부분이라고 생각이 든다.  
2. `convert()` 를 인터페이스로 추상화 
3. `authenticate()`를 인터페이스로 추상화 
4. SecurityContextInterceptor 로 추상화 

**생각난 점**
1. `checkAuthentication()`에 대해서 공통된 로직을 사용하므로 템플릿 메서드 패턴 구조도 괜찮을 것 같다.  
2. CustomUserDetailsService 는 authenticate 에서만 사용한다.(콜백 패턴도 생각났지만, 스프링 지원 인터페이스 다름 + 오버 엔지니링)  

**구현하다보니**  
1. LoginMember 또한, Auth 관련 클래스들에서 사용되므로 실질적으로 auth -> member 의존성이라 판단되어 추상화 적용 
